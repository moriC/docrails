.EN	Active Record Query Interface
.EN	=============================
.JA	Active Record クエリインタフェース
.JA	=====================================

.EN	This guide covers different ways to retrieve data from the database using Active Record.
.JA	本ガイドでは、Active Record を使ってデータベースからデータをとってくるさまざまな方法を説明します。

.EN	After reading this guide, you will know:
.JA	このガイドを読むことで、以下のようなことがわかるでしょう。:

.EN	* How to find records using a variety of methods and conditions.
.EN	* How to specify the order, retrieved attributes, grouping, and other properties of the found records.
.EN	* How to use eager loading to reduce the number of database queries needed for data retrieval.
.EN	* How to use dynamic finders methods.
.EN	* How to check for the existence of particular records.
.EN	* How to perform various calculations on Active Record models.
.EN	* How to run EXPLAIN on relations.
.JA	* いろんなメソッドや条件を使ってレコードを検索する方法
.JA	* 検索できたレコードの順番や、抽出するカラムや、グルーピングなどのプロパティを指定する方法
.JA	* Eager loading を使うことで、データの抽出に必要なデータベースクエリの数を減らす方法
.JA	* 動的finderメソッドを使う方法
.JA	* 特定のレコードについて存在するかどうかを調べる方法
.JA	* Active Record モデルで様々な計算を実行する方法
.JA	* 関連で EXPLAIN を走らせる方法

--------------------------------------------------------------------------------

.EN	If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.
.JA	もし生のSQLを使ってデータベースレコードを検索しているなら、Rails で同じことするにはもっと良い方法があるのだと大体わかるでしょう。Active Record を使えばほとんどの場合においてSQLを使う必要はありません。

.EN	Code examples throughout this guide will refer to one or more of the following models:
.JA	本ガイドに登場するコード例では、次のようなモデルを使います:

.EN	TIP: All of the following models use `id` as the primary key, unless specified otherwise.
.JA	TIP: 以下に示すモデルはすべて、特に指定がない限りは主キーとして `id` を使います。

	```ruby
	class Client < ActiveRecord::Base
	  has_one :address
	  has_many :orders
	  has_and_belongs_to_many :roles
	end
	```

	```ruby
	class Address < ActiveRecord::Base
	  belongs_to :client
	end
	```

	```ruby
	class Order < ActiveRecord::Base
	  belongs_to :client, counter_cache: true
	end
	```

	```ruby
	class Role < ActiveRecord::Base
	  has_and_belongs_to_many :clients
	end
	```

.EN	Active Record will perform queries on the database for you and is compatible with most database systems (MySQL, PostgreSQL and SQLite to name a few). Regardless of which database system you're using, the Active Record method format will always be the same.
.JA	Active Record はデータベースに対してクエリを実行します。また Active Record はほとんどのデータベースシステム (いくつか例を挙げますと MySQL や PostgreSQL や SQLite) で互換性があります。どのデータベースシステムを使おうとも、Active Record のメソッド形式はつねに同じです。

.EN	Retrieving Objects from the Database
.EN	------------------------------------
.JA	h3. デーベースから 1 件取り出す

.EN	To retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.
.JA	データベースからオブジェクトを取り出すために、Active Record は検索用メソッドをいくつか用意しています。それぞれのファインダメソッドに引数を渡すことで、生のSQLを書くことなしに、データベースに対して特定のクエリを実行することができます。

.EN	The methods are:
.JA	そのためのメソッドがこちらです:

	* `bind`
	* `create_with`
	* `eager_load`
	* `extending`
	* `from`
	* `group`
	* `having`
	* `includes`
	* `joins`
	* `limit`
	* `lock`
	* `none`
	* `offset`
	* `order`
	* `preload`
	* `readonly`
	* `references`
	* `reorder`
	* `reverse_order`
	* `select`
	* `uniq`
	* `where`

.EN	All of the above methods return an instance of `ActiveRecord::Relation`.
.JA	上記のメソッドはどれも `ActiveRecord::Relation` のインスタンスを返します。

.EN	The primary operation of `Model.find(options)` can be summarized as:
.JA	`Model.find(options)` の主な操作をまとめると:

.EN	* Convert the supplied options to an equivalent SQL query.
.EN	* Fire the SQL query and retrieve the corresponding results from the database.
.EN	* Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
.EN	* Run `after_find` callbacks, if any.
.JA	* 与えられたオプションを同等の SQL クエリに変換すること。
.JA	* SQL クエリを実行し、対応する結果をデータベースから抽出すること。
.JA	* 各行に応じたモデルの Ruby オブジェクトを作成すること。
.JA	* もしあれば after_find コールバックを呼び出すこと。

.EN	### Retrieving a Single Object
.JA	### オブジェクトをひとつ取り出す

.EN	Active Record provides five different ways of retrieving a single object.
.JA	Active Record は、オブジェクトをひとつ取り出す方法を 5 つ用意しています。

.EN	#### Using a Primary Key
.JA	#### 主キーを使う

.EN	Using `Model.find(primary_key)`, you can retrieve the object corresponding to the specified _primary key_ that matches any supplied options. For example:
.JA	`Model.find(primary_key`) を使うことで、 _primary key_ に対応したオブジェクトやオプションに一致したオブジェクトを取り出せます。たとえば:

	```ruby
.EN	# Find the client with primary key (id) 10.
.JA	# 主キー (id) が 10 である顧客を検索する
	client = Client.find(10)
	# => #<Client id: 10, first_name: "Ryan">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQl は:

	```sql
	SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
	```

.EN	`Model.find(primary_key)` will raise an `ActiveRecord::RecordNotFound` exception if no matching record is found.
.JA	`Model.find(primary_key)` は、もし該当するレコードが見つからなければ、`ActiveRecord::RecordNotFound` 例外を発生させます。

.EN	#### `take`
.JA	#### `take`

.EN	`Model.take` retrieves a record without any implicit ordering. For example:
.JA	`Model.take` は、順番を関係なしにひとつのレコードを取り出します。たとえば:

	```ruby
	client = Client.take
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 1
	```

.EN	`Model.take` returns `nil` if no record is found and no exception will be raised.
.JA	`Model.take` は、レコードがひとつも見つけられなくても例外は発生しません。

.EN	TIP: The retrieved record may vary depending on the database engine.
.JA	TIP: レコードを取り出すことはデータベースエニジンによって動作が変わることがあります。

.EN	#### `first`
.JA	#### `first`

.EN	`Model.first` finds the first record ordered by the primary key. For example:
.JA	`Model.first` は、主キーで並べたときの最初のレコードを返します。たとえば:

	```ruby
	client = Client.first
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これに同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
	```

.EN	`Model.first` returns `nil` if no matching record is found and no exception will be raised.
.JA	`Model.first` は、一致するレコードがなければ nil を返します。例外は発生しません。

.EN	#### `last`
.JA	#### `last`

.EN	`Model.last` finds the last record ordered by the primary key. For example:
.JA	`Model.last` は、主キーで並べたときの最後のレコードを返します。たとえば:

	```ruby
	client = Client.last
	# => #<Client id: 221, first_name: "Russel">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
	```

.EN	`Model.last` returns `nil` if no matching record is found and no exception will be raised.
.JA	`Model.last` は、もし一致するレコードがなければ `nil` を返します。例外は発生しません。

.EN	#### `find_by`
.JA	#### `find_by`

.EN	`Model.find_by` finds the first record matching some conditions. For example:
.JA	`Model.find_by` は、いくつかの条件に一致する最初のレコードを見つけます。たとえば:

	```ruby
	Client.find_by first_name: 'Lifo'
	# => #<Client id: 1, first_name: "Lifo">

	Client.find_by first_name: 'Jon'
	# => nil
	```

.EN	It is equivalent to writing:
.JA	これは以下の書き方と同じです。

	```ruby
	Client.where(first_name: 'Lifo').take
	```

.EN	#### `take!`
.JA	#### `take!`

.EN	`Model.take!` retrieves a record without any implicit ordering. For example:
.JA	`Model.take!` は、順番を関係なしにひとつのレコードを取り出します。たとえば:

	```ruby
	client = Client.take!
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 1
	```

.EN	`Model.take!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.take!` は一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

.EN	#### `first!`
.JA	#### `first!`

.EN	`Model.first!` finds the first record ordered by the primary key. For example:
.JA	`Model.first!` は、主キーで並べたときの最初のレコードを返します。たとえば:

	```ruby
	client = Client.first!
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
	```

.EN	`Model.first!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.first!` は一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

.EN	#### `last!`
.JA	#### `last!`

.EN	`Model.last!` finds the last record ordered by the primary key. For example:
.JA	`Model.last!` は、主キーで並べた最後のレコードを返します。たとえば:

	```ruby
	client = Client.last!
	# => #<Client id: 221, first_name: "Russel">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は

	```sql
	SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
	```

.EN	`Model.last!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.last!` は一致するレコードがなければ、`ActiveRecord:RecordNotFound` が発生します。

.EN	#### `find_by!`
.JA	#### `find_by!`

.EN	`Model.find_by!` finds the first record matching some conditions. It raises `ActiveRecord::RecordNotFound` if no matching record is found. For example:
.JA	`Model.find_by` 条件に一致する最初のレコードを返します。もし一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

	```ruby
	Client.find_by! first_name: 'Lifo'
	# => #<Client id: 1, first_name: "Lifo">

	Client.find_by! first_name: 'Jon'
	# => ActiveRecord::RecordNotFound
	```

.EN	It is equivalent to writing:
.JA	これはこのように書くのと同じです。

	```ruby
	Client.where(first_name: 'Lifo').take!
	```

.EN	### Retrieving Multiple Objects
.JA	### 複数のオブジェクトを取り出す

.EN	#### Using Multiple Primary Keys
.JA	#### 複数の主キーを使う

.EN	`Model.find(array_of_primary_key)` accepts an array of _primary keys_, returning an array containing all of the matching records for the supplied _primary keys_. For example:
.JA	`Model.find(array_of_primary_key)` は、引数として _primary keys_ の配列を取ることができます。この場合、指定された _primary keys_ にマッチしたレコードを含んだ配列を返します。たとえば:

	```ruby
.EN	# Find the clients with primary keys 1 and 10.
.JA	# 主キーが 1 と 10 の顧客を検索する
	client = Client.find([1, 10]) # Or even Client.find(1, 10)
	# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients WHERE (clients.id IN (1,10))
	```

.EN	WARNING: `Model.find(array_of_primary_key)` will raise an `ActiveRecord::RecordNotFound` exception unless a matching record is found for **all** of the supplied primary keys.
.JA	WARNING: `Model.find(array_of_primary_key)` は、指定された主キーにマッチするレコードが**ひとつでも**見つからない場合は、`ActiveRecord::RecordNotFound` 例外を発生させます〔訳注: すべて見つかった場合のみ例外は発生しない〕。

	#### take

.EN	`Model.take(limit)` retrieves the first number of records specified by `limit` without any explicit ordering:
.JA	`Model.take(limit)` は、並び換えを行なわず `limit` に指定した数だけ最初のレコードを返します。:

	```ruby
	Client.take(2)
	# => [#<Client id: 1, first_name: "Lifo">,
	      #<Client id: 2, first_name: "Raf">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 2
	```

.EN	#### first

.EN	`Model.first(limit)` finds the first number of records specified by `limit` ordered by primary key:
.JA	`Model.first(limit)` 主キーによって並び換えをして `limit` に指定した数だけのレコードを返します。

	```ruby
	Client.first(2)
	# => [#<Client id: 1, first_name: "Lifo">,
	      #<Client id: 2, first_name: "Raf">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 2
	```

	#### last

.EN	`Model.last(limit)` finds the number of records specified by `limit` ordered by primary key in descending order:
.JA	`Model.last(limit)` は、主キーの逆順の順番で `limit` に指定された数だけのレコードを返します。

	```ruby
	Client.last(2)
	# => [#<Client id: 10, first_name: "Ryan">,
      #<Client id: 9, first_name: "John">]
```

.EN	The SQL equivalent of the above is:

	```sql
	SELECT * FROM clients ORDER By id DESC LIMIT 2
	```

.EN	### Retrieving Multiple Objects in Batches
.JA	### 複数のオブジェクトをバッチ方式で取り出す

.EN	Sometimes you need to iterate over a large set of records. For example to send a newsletter to all users, to export some data, etc. 
.JA	時には、非常にたくさんのレコードに対して繰り返しを行わなければならないことがあります。たとえば、全ユーザに対してニュースレターを送信する場合や、何らかのデータをエクスポート (export) する場合などです。

.EN	The following may seem very straight forward at first:
.JA	まず最初に、ごく単純な方法を示します:

	```ruby
.EN	# Very inefficient when users table has thousands of rows.
.JA	# users テーブルが数千行ある場合はとても効率が悪い
	User.all.each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	But if the total number of rows in the table is very large, the above approach may vary from being under performant to just plain impossible.
.JA	しかしテーブル内の行数が非常に多いと、このアプローチではパフォーマンスが悪かったり、最悪だと実行すらできないことがあります。

.EN	This is because `User.each` makes Active Record fetch _the entire table_, build a model object per row, and keep the entire array in the memory. Sometimes that is just too many objects and demands too much memory.
.JA	これは、`User.each` が _テーブル全体_ に対して Active Record によるフェッチを行い、行ごとのモデルオブジェクトを作成し、それらをすべてメモリ上の配列に格納してしまうことが原因です。時にはこの方法はあまりに多くのオブジェクトを作成してしまうため、一度にあまりに多くのメモリを消費することになります。

.EN	#### `find_each`
.JA	#### `find_each`

.EN	To efficiently iterate over a large table, Active Record provides a batch finder method called `find_each`:
.JA	巨大なテーブル全体に対して効率的に繰り返しを行うために、Active Record はバッチ形式の検索用メソッドである `find_each` を提供しています:

	```ruby
	User.find_each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	*Configuring the batch size*
.JA	*バッチサイズを設定する*

.EN	Behind the scenes `find_each` fetches rows in batches of `1000` and yields them one by one. The size of the underlying batches is configurable via the `:batch_size` option.
.JA	`find_each` の裏側では、1 回のバッチで `1000` 行がフェッチされてから 1 行ずつ yield が実行されます。この、裏側で行われているバッチのサイズを変更するには、`:batch_size` オプションを指定します。

.EN	To fetch `User` records in batch size of `5000`:
.JA	バッチサイズ `5000` で `User` のレコードを取ってくるには:

	```ruby
	User.find_each(batch_size: 5000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	*Starting batch find from a specific primary key*
.JA	*バッチによる検索を開始するときの主キーを指定する*

.EN	Records are fetched in ascending order on the primary key, which must be an integer. The `:start` option allows you to configure the first ID of the sequence if the lowest is not the one you need. This may be useful for example to be able to resume an interrupted batch process if it saves the last processed ID as a checkpoint.
.JA	レコードは主キーの昇順でフェッチされます。主キーは整数でなければなりません。番号の小さいものは必要としない場合、 `:start` オプションを使えば、取り出すべき一連のレコードにおける最初の ID を設定できます。これは、たとえばバッチ処理が中断された場合に、最後に処理したレコードの ID をチェックポイントとして保存しておき、あとでその ID から処理を再開するような場合に役に立ちます。

.EN	To send newsletters only to users with the primary key starting from `2000`:
.JA	主キーが `2000` 以降のユーザにだけニュースレターを送信する場合は:

	```ruby
	User.find_each(start: 2000, batch_size: 5000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	*Additional options*
.JA	*追加できるオプション*

.EN	`find_each` accepts the same options as the regular `find` method. However, `:order` and `:limit` are needed internally and hence not allowed to be passed explicitly.
.JA	`find_each` は通常の `find` メソッドと同じオプションが利用できます。ただし `:order` と `:limit` は内部的に使用されるため、これらを `find_each` で明示的に指定することはできません。

.EN	#### `find_in_batches`
.JA	#### `find_in_batches`

.EN	You can also work by chunks instead of row by row using `find_in_batches`. This method is analogous to `find_each`, but it yields arrays of models instead:
.JA	1 行ずつ処理を行うかわりに、`find_in_batches` を使うことでチャンク〔訳注: データの固まりのこと。ここでは配列を意味する〕ごとに処理を行うこともできます。このメソッドは `find_each` に似てますが、〔訳注: モデルのかわりに〕モデルの配列を受け取って yield します:

	```ruby
.EN	# Works in chunks of 1000 invoices at a time.
.JA	# 1 回につき 1000 件のインボイスを含むチャンクを処理する
	Invoice.find_in_batches(include: :invoice_lines) do |invoices|
	  export.add_invoices(invoices)
	end
	```

.EN	The above will yield the supplied block with `1000` invoices every time.
.JA	上のコードは毎回 1000 個のインボイスを使って、指定されたブロックを yield します。

.EN	Conditions
.EN	----------
.JA	検索条件
.JA	--------

.EN	The `find` method allows you to specify conditions to limit the records returned, representing the `WHERE`-part of the SQL statement. Conditions can either be specified as a string, array, or hash.
.JA	find メソッドでは、返されるレコードを限定するための検索条件を指定できます。これは SQL 文でいうところの WHERE 句で表されます。条件は文字列や配列やハッシュで指定できます。

.EN	### Pure String Conditions
.JA	### 文字列だけを使った検索条件

.EN	If you'd like to add conditions to your find, you could just specify them in there, just like `Client.where("orders_count = '2'")`. This will find all clients where the `orders_count` field's value is 2.
.JA	もし find に検索条件を追加するなら、それをたとえば `Client.where("orders_count = '2'")` のようにその場で指定でき、この場合なら `orders_count` フィールドの値が 2 であるようなクライアントをすべて検索します。

.EN	WARNING: Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, `Client.where("name LIKE '%#{params[:name]}%'")` is not safe. See the next section for the preferred way to handle conditions using an array.
.JA	警告: 条件を文字列だけで組み立てるのは、SQL インジェクションの脆弱性を残してしまう危険性が高いです。たとえば `Client.where("name LIKE '%#{params[:name]}%'")` は安全ではありません。次のセクションで、配列を使って検索条件を構築するという、より好ましい方法を説明します。

.EN	### Array Conditions
.JA	### 配列を使った検索条件

.EN	Now what if that number could vary, say as an argument from somewhere, or perhaps from the user's level status somewhere? The find then becomes something like:
.JA	たとえば何かの引数をもとにしたり、ユーザレベルのステータスとかなにかをもとにするといった、数値が変化するような場合はどうするのでしょう?

	```ruby
	Client.where("orders_count = ?", params[:orders])
	```

.EN	Active Record will go through the first element in the conditions value and any additional elements will replace the question marks `(?)` in the first element.
.JA	Active Record は条件値の最初の要素を取り出し、その中のクエスチョンマーク `(?)` を残りの要素で置き換えます。

.EN	Or if you want to specify two conditions, you can do it like:
.JA	あるいは、もし 2 つの条件を指定したい場合は次のようにします:

	```ruby
	Client.where("orders_count = ? AND locked = ?", params[:orders], false)
	```

.EN	In this example, the first question mark will be replaced with the value in `params[:orders]` and the second will be replaced with the SQL representation of `false`, which depends on the adapter.
.JA	この例では、1 つ目のクエスチョンマークは `params[:orders]` の値で置き換わり、2 つ目は `false` の SQL 的表現 (これはアダプタごとに異なります) で置き換わります。

.EN	The reason for doing code like:
.JA	〔訳注: 「?」を使った〕次のような書き方は:

.EN	```ruby
.EN	Client.where("orders_count = ?", params[:orders])
.EN	```

.EN	instead of:
.JA	〔訳注: 「#{}」を使った〕次のような書き方よりも:

.EN	```ruby
.EN	Client.where("orders_count = #{params[:orders]}")
.EN	```

.EN	is because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database *as-is*. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out he or she can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.
.JA	安全性の点において望ましいといえます。条件式の文字列に値を直接埋め込むと、値をデータベースに *そのままの形で* 渡してしまいます。これはつまり、その値というのが、悪意を持ったユーザによるエスケープされてない値である可能性があるということです。もしそうなった場合、悪意を持ったユーザがその弱点を見つけてしまえば、それを突いてデータベースに対して何でもできてしまうため、データベース全体が危険に晒されてしまいます。条件式の文字列に引数を直接埋め込むようなことは決してしてはいけません。

.EN	TIP: For more information on the dangers of SQL injection, see the "Ruby on Rails Security Guide":security.html#sql-injection.
.JA	TIP: SQL インジェクションの危険性についてのより詳しい情報は、"Ruby on Rails Security Guide":security.html#sql-injection を参照してください。

.EN	#### Placeholder Conditions
.JA	#### プレースホルダを使った検索条件

.EN	Similar to the `(?)` replacement style of params, you can also specify keys/values hash in your array conditions:
.JA	「 `?` 」を使った置換と似たような方法として、配列の条件式にハッシュのキーと値で指定することもできます:

	```ruby
	Client.where("created_at >= :start_date AND created_at <= :end_date",
	  {start_date: params[:start_date], end_date: params[:end_date]})
	```

.EN	This makes for clearer readability if you have a large number of variable conditions.
.JA	この方法は、条件式の可変部が多い場合は可読性がより高くなります。

.EN	### Hash Conditions
.JA	### ハッシュを使った検索条件

.EN	Active Record also allows you to pass in a hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want conditionalised and the values of how you want to conditionalise them:
.JA	Active Record では、Hash による検索条件 (Hash Conditions) を使うことができます。これを使うと、条件式の可読性が向上します。Hash による検索条件を使うことで、条件式で使いたいフィールド名をキーとし、条件として使いたい値を Hash の値に指定できます:

.EN	NOTE: Only equality, range and subset checking are possible with Hash conditions.
.JA	NOTE: 同様に、範囲式やサブセットチェック (subset checking)〔訳注: ???〕も Hash による検索条件で利用可能です。

.EN	#### Equality Conditions
.JA	#### 等号による検索条件

	```ruby
	Client.where({ locked: true })
	```

.EN	The field name does not have to be a symbol it can also be a string:
.JA	フィールド名は Symbol である必要はなく、String でもよいです:

	```ruby
	Client.where({ 'locked' => true })
	```

.EN	The good thing about this is that we can pass in a range for our fields without it generating a large query as shown in the preamble of this section.
.JA	Hash による検索条件のよいところは、フィールドの Range オブジェクトを渡した場合に、前のセクションで見たような巨大なクエリを生成しないという点です。

	```ruby
	Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
	```

.EN	This will find all clients created yesterday by using a `BETWEEN` SQL statement:
.JA	この場合だと、昨日作成されたすべての顧客情報を、SQL 文の BETWEEN を使って検索します:

	```sql
	SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
	```

.EN	This demonstrates a shorter syntax for the examples in "Array Conditions":#array-conditions
.JA	このデモンストレーションは、配列による検索条件よりも短く書ける例となっています。

.EN	#### Subset Conditions
.JA	#### 部分集合による検索条件

.EN	If you want to find records using the `IN` expression you can pass an array to the conditions hash:
.JA	もし `IN` 演算子を使ってレコードを検索したいなら、ハッシュの値に配列を渡せばよいです:

	```ruby
	Client.where(orders_count: [1,3,5])
	```

.EN	This code will generate SQL like this:
.JA	この場合なら次のような SQL が生成されます:

	```sql
	SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
	```

.EN	Ordering
.EN	--------
.JA	順序
.JA	----

.EN	To retrieve records from the database in a specific order, you can specify the `:order` option to the `find` call.
.JA	データベースからある特定の順番でレコードを抽出するには、`:order` オプションつきで `find` メソッドを呼び出します。

.EN	For example, if you're getting a set of records and want to order them in ascending order by the `created_at` field in your table:
.JA	たとえば、`created_at` フィールドの昇順でテーブルからレコードを取り出したいなら:

.EN	```ruby
.EN	Client.order("created_at")
.EN	```

.EN	You could specify `ASC` or `DESC` as well:
.JA	ASC〔訳注: 昇順〕または DESC〔訳注: 降順〕を指定できます:

	```ruby
	Client.order("created_at DESC")
.EN	# OR
.JA	# または
	Client.order("created_at ASC")
	```

.EN	Or ordering by multiple fields:
.JA	あるいは複数のフィールドを指定して:

	```ruby
	Client.order("orders_count ASC, created_at DESC")
	```

.EN	Selecting Specific Fields
.EN	-------------------------
.JA	特定のフィールドだけを選択する
.JA	--------------------------------

.EN	By default, `Model.find` selects all the fields from the result set using `select *`.
.JA	デフォルトでは、`Model.find` は `select *`を使って結果セット (result set) からすべてのフィールドを選択します。

.EN	To select only a subset of fields from the result set, you can specify the subset via the `select` method.
.JA	結果セットから一部のフィールドだけを取り出すには、select メソッドでフィールド名を指定する必要があります。

.EN	For example, to select only `viewable_by` and `locked` columns:
.JA	たとえば、 `viewable_by` カラムと `locked` カラムのみを選択するには:

	```ruby
	Client.select("viewable_by, locked")
	```

.EN	The SQL query used by this find call will be somewhat like:
.JA	この find メソッド呼び出しによって生成される SQL クエリはだいたい次の通りです:

	```sql
	SELECT viewable_by, locked FROM clients
	```

.EN	Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:
.JA	モデルオブジェクトのうち、指定されたフィールドのみが初期化されることに注意してください。もし初期化されてないフィールドにアクセスすると、次のようなエラーになります:

	```bash
	ActiveModel::MissingAttributeError: missing attribute: <attribute>
    ````

.EN	Where `<attribute>` is the attribute you asked for. The `id` method will not raise the `ActiveRecord::MissingAttributeError`, so just be careful when working with associations because they need the `id` method to function properly.
.JA	ここで `<attribute>` はアクセスしようとしている属性です。`id` メソッドは `ActiveRecord::MissingAttributeError` を発生させませんが、アソシエーションは id メソッドが正しく機能することが必要なので、 `id` メソッドを使う場合は注意してください。

.EN	You can also call SQL functions within the select option. For example, if you would like to only grab a single record per unique value in a certain field by using the `DISTINCT` function you can do it like this:
.JA	また select オプション内で SQL 関数を指定することができます。たとえば、 `DISTINCT` 関数を使うことであるフィールドにおける一意な値ごとに 1 つのレコードのみを取り出したいなら、次のようにします:

	```ruby
	query = Client.select(:name).uniq
	# => Returns unique names

	query.uniq(false)
	# => Returns all names, even if there are duplicates
	```

.EN	Limit and Offset
.EN	----------------
.JA	Limit と Offset
.JA	---------------

.EN	To apply `LIMIT` to the SQL fired by the `Model.find`, you can specify the `LIMIT` using `limit` and `offset` methods on the relation.
.JA	`Model.find` メソッドで SQL フィールドに `LIMIT` を適用するには、`limit` および `offset` メソッドをリレーションに指定します。

.EN	If you want to limit the amount of records to a certain subset of all the records retrieved you usually use `limit` for this, sometimes coupled with `offset`. Limit is the maximum number of records that will be retrieved from a query, and offset is the number of records it will start reading from from the first record of the set. For example:
.JA	もし抽出される全レコードのうち、レコードの総数を制限したサブセットのみを取り出したい場合、 `limit` オプションと、必要ならば `offset` オプションも使用します。 Limit オプションはクエリから抽出されるレコードの最大数を表し、offset オプションは抽出されたレコードセットの読み取り開始場所を指定します。たとえば:

	```ruby
	Client.limit(5)
	```

.EN	This code will return a maximum of 5 clients and because it specifies no offset it will return the first 5 clients in the table. The SQL it executes will look like this:
.JA	このコードは最大で 5 個の Client オブジェクトを返します。また offset オプションが指定されてないので、テーブルの最初から数えて 5 番目までを返します。上のコードは次のような SQL を実行します:

.EN	```sql
.EN	SELECT * FROM clients LIMIT 5
.EN	```

.EN	Or chaining both `limit` and `offset`:
.JA	あるいは `limit` と `offset` の両方を指定するには:

	```ruby
	Client.limit(5).offset(30)
	```

.EN	This code will return a maximum of 5 clients and because it specifies an offset this time, it will return these records starting from the 5th client in the clients table. The SQL looks like:
.JA	このコードは最大で 5 個の Client オブジェクトを返しますが、今回は offset が指定されているので、clients テーブルにおいて 5 番目のレコードから開始します。SQL は次の通りです:

	```sql
	SELECT * FROM clients LIMIT 5 OFFSET 30
	```

.EN	Group
.EN	-----
.JA	Group
.JA	-----

.EN	To apply `GROUP BY` clause to the SQL fired by the finder, you can specify the `group` method on the find.
.JA	検索用メソッドで実行される SQL に `GROUP BY` を適用するには、 `group` メソッドを指定します。

.EN	For example, if you want to find a collection of the dates orders were created on:
.JA	たとえば、すべての日付を取り出し、かつ日付順でソートしたい場合:

	```ruby
	Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
	```

.EN	And this will give you a single `Order` object for each date where there are orders in the database.
.JA	この場合なら、データベース内の日付順で、各日付ごとに `Order` オブジェクトをひとつ返します。

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	```sql
	SELECT date(created_at) as ordered_date, sum(price) as total_price
	FROM orders
	GROUP BY date(created_at)
	```

.EN	Having
.EN	------
.JA	Having
.JA	------

.EN	SQL uses `HAVING` clause to specify conditions on the `GROUP BY` fields. You can specify the `HAVING` clause to the SQL fired by the `Model.find` using `:having` option on the find.
.JA	`GROUP BY` で指定したフィールドに対する条件は、SQL では `HAVING` 句で指定します。 `Model.find` の `:having` オプションを使うと、SQL での `HAVING` 句を指定できます。

.EN	For example:
.JA	たとえば:

	```ruby
	Order.select("date(created_at) as ordered_date, sum(price) as total_price").
	  group("date(created_at)").having("sum(price) > ?", 100)
	```

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	```sql
	SELECT date(created_at) as ordered_date, sum(price) as total_price
	FROM orders
	GROUP BY date(created_at)
	HAVING sum(price) > 100
	```

.EN	This will return single order objects for each day, but only for the last month.
.JA	この例だと各日付ごとに Order オブジェクトをひとつ返しますが、日付が条件を満たす場合のみです。

.EN	Readonly Objects
.EN	----------------
.JA	読み取り専用オブジェクト
.EN	--------------------------

.EN	To explicitly disallow modification/destruction of the matching records returned in a Relation object, you could chain the `readonly` method as `true` to the find call.
.JA	リレーションによって返されたレコードが変更されたり破壊されるのを明示的に防ぐには、 `readonly` メソッドに `true` を指定しておいてから、find の呼び出しを繋げます。

.EN	Any attempt to alter or destroy the readonly records will not succeed, raising an `ActiveRecord::ReadOnlyRecord` exception. To set this option, specify it like this:
.JA	読取専用レコードに対して変更や削除を行うことはできず、例外 `ActiveRecord::ReadOnlyRecord` が発生します。このオプションを指定するには、次のようにしてください:

	```ruby
	Client.first.readonly(true)
	```

.EN	If you assign this record to a variable client, calling the following code will raise an `ActiveRecord::ReadOnlyRecord` exception:
.JA	もしこのレコードを変数 client に代入して、次のようなコードを実行すると、 `ActiveRecord::ReadOnlyRecord` 例外が発生します:

	```ruby
	client = Client.first.readonly(true)
	client.locked = false
	client.save
	```

.EN	Locking Records for Update
.EN	--------------------------
.JA	更新用にレコードをロックする
.JA	------------------------------

.EN	Locking is helpful for preventing the race conditions when updating records in the database and ensuring atomic updated. Active Record provides two locking mechanism:
.JA	ロックは、データベース中のレコードを更新するときに競合条件 (Race condition) を避けるのに役立ちます。また更新をアトミックに行うことも保証してくれます。 Active Record は 2 種類のロックメカニズムを提供しています:

.EN	* Optimistic Locking
.EN	* Pessimistic Locking
.JA	* 楽観的ロック
.JA	* 悲観的ロック

.EN	### Optimistic Locking
.JA	### 楽観的ロック

.EN	Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data.  It does this by checking whether another process has made changes to a record since it was opened. An `ActiveRecord::StaleObjectError` exception is thrown if that has occurred and the update is ignored.
.JA	楽観的ロックは、複数のユーザが同じレコードに更新のためにアクセスする場合において、データの衝突 (conflict) があまりないことを仮定した方法です。この方法では、対象レコードを取り出して以降、〔訳注: 更新する際に〕他のプロセスがそのレコードに対して変更を行ったかどうかをチェックします。もし〔訳注: 他プロセスによる変更が〕行われていた場合は `ActiveRecord::StaleObjectError` が発生し、更新は行われません。

.EN	**Optimistic locking column**
.JA	**楽観的ロック用のカラム**

.EN	In order to use optimistic locking, the table needs to have a column called `lock_version`. Each time the record is updated, Active Record increments the `lock_version` column and the locking facilities ensure that records instantiated twice will let the last one saved raise an `ActiveRecord::StaleObjectError` exception if the first was also updated. Example:
.JA	楽観的ロッックを使用する場合、 `lock_version` という名前のカラムがテーブルに必要です。レコードが更新されるたびに、Active Record は `lock_version` カラムの値を 1 増やします。こうすることでロック機構は、同じレコードが 2 度インスタンス化されてかつ最初のほうが更新された場合、2 つめのほうがセーブされたときに `ActiveRecord::StaleObjectError` 例外を必ず発生させます。

	```ruby
	c1 = Client.find(1)
	c2 = Client.find(1)

	c1.first_name = "Michael"
	c1.save

	c2.name = "should fail"
.EN	c2.save # Raises an ActiveRecord::StaleObjectError
.JA	c2.save # ActiveRecord::StaleObjectError 例外が発生する
	```

.EN	You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.
.JA	更新が衝突したときに、例外を rescue して、ロールバックしたり更新をマージしたりあるいは衝突を解消する何らかのビジネスロジックを実行するのは、開発者の仕事となります。

.EN	This behavior can be turned off by setting `ActiveRecord::Base.lock_optimistically = false`.
.JA	この挙動は `ActiveRecord::Base.lock_optimistically = false` によってオフにすることができます。

.EN	To override the name of the `lock_version` column, `ActiveRecord::Base` provides a class method called `set_locking_column`:
.JA	`lock_version` カラムの名前を変更するために、`ActiveRecord::Base` は `set_locking_column` というメソッドを用意しています:

	```ruby
	class Client < ActiveRecord::Base
	  self.locking_column = :lock_client_column
	end
	```

.EN	### Pessimistic Locking
.JA	### 悲観的ロック

.EN	Pessimistic locking uses locking mechanism provided by the underlying database. Passing `lock: true` to `Model.find` obtains an exclusive lock on the selected rows. `Model.find` using `:lock` are usually wrapped inside a transaction for preventing deadlock conditions.
.JA	悲観的ロックは、データベースが持っている機能を使ったロックメカニズムです。 `Model.find` を `lock: true` に渡すことで、選択された行に排他的ロックをかけることができます。 `:lock` つきの `Model.find` は通常、デッドロック条件を防ぐためにトランザクション内で使用されます。

.EN	For example:
.JA	たとえば:

	```ruby
	Item.transaction do
	  ji = Item.lock.first
	  i.name = 'Jones'
	  i.save
	end
	```

.EN	The above session produces the following SQL for a MySQL backend:
.JA	このセッションは次のような SQL を生成します (MySQL の場合):

	```sql
	SQL (0.2ms)   BEGIN
	Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
	Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
	SQL (0.8ms)   COMMIT
	```

.EN	You can also pass raw SQL to the `:lock` option to allow different types of locks. For example, MySQL has an expression called `LOCK IN SHARE MODE` where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:
.JA	また `:lock` オプションには生の SQL を渡すことで別の種類のロックを使うこともできます。たとえば MySQL には `LOCK IN SHARE MODE` という式があり、これはレコードにロックをかけるけど他のユーザがクエリで読み取ることは許すというものです。この式を指定するには、lock オプションにその式をそのまま渡します:

	```ruby
	Item.transaction do
      i = Item.lock("LOCK IN SHARE MODE").find(1)
	  i.increment!(:views)
	end
	```

.EN	Joining Tables
.EN	--------------
.JA	テーブルのジョイン
.JA	-------------------

.EN	`Model.find` provides a `:joins` option for specifying `JOIN` clauses on the resulting SQL. There multiple different ways to specify the `:joins` option:
.JA	`Model.find` は SQL における `JOIN` 句を指定するための `:joins` オプションを提供しています。`:joins` オプションの指定方法は複数あります:

.EN	### Using a String SQL Fragment
.JA	### 文字列による SQL フラグメントを使った方法

.EN	You can just supply the raw SQL specifying the `JOIN` clause to the `:joins` option. For example:
.JA	`:joins` オプションに、`JOIN` 句を表す生の SQL を指定できます。たとえば:

	```ruby
	Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
	```

.EN	This will result in the following SQL:
.JA	これは次のような SQL になります:

	```sql
	SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
	```

.EN	### Using Array/Hash of Named Associations
.JA	### 名前付きアソシエーションの配列またはハッシュを使う

.EN	WARNING: This method only works with `INNER JOIN`,
.JA	WARNING: この方法は `INNER JOIN` に対してのみ有効。

.EN	Active Record lets you use the names of the "associations":association_basics.html defined on the model as a shortcut for specifying the `:joins` option.
.JA	Active Record では `:joins` オプションを指定するときに、モデルクラスで定義された "アソシエーション":association_basics.html の名前を短縮名として指定できます。

.EN	For example, consider the following `Category`, `Post`, `Comments` and `Guest` models:
.JA	たとえば、 `Category` と `Post` と `Comments` と `Guest` というモデルがあったとします:

	```ruby
	class Category < ActiveRecord::Base
	  has_many :posts
	end

	class Post < ActiveRecord::Base
	  belongs_to :category
	  has_many :comments
	  has_many :tags
	end

	class Comment < ActiveRecord::Base
	  belongs_to :post
	  has_one :guest
	end

	class Guest < ActiveRecord::Base
	  belongs_to :comment
	end

	class Tag < ActiveRecord::Base
	  belongs_to :post
	end
	```

.EN	Now all of the following will produce the expected join queries using `INNER JOIN`:
.JA	この場合、以下に示す例のすべてで、 `INNER JOIN` を使った期待通りの join クエリが生成されます:

.EN	#### Joining a Single Association
.JA	#### 単一のアソシエーションによるジョイン

	```ruby
	Category.joins(:posts)
	```

.EN	This produces:
.JA	この結果は次の通りです:

	```sql
	SELECT categories.* FROM categories
	  INNER JOIN posts ON posts.category_id = categories.id
	```

.EN	#### Joining Multiple Associations
.JA	#### 複数のアソシエーションによるジョイン

	```ruby
	Post.joins(:category, :comments)
	```

.EN	This produces:
.JA	この結果は次の通りです:

	```sql
	SELECT posts.* FROM posts
	  INNER JOIN categories ON posts.category_id = categories.id
	  INNER JOIN comments ON comments.post_id = posts.id
	```

.EN	#### Joining Nested Associations (Single Level)
.JA	#### 入れ子 (1 段) になったアソシエーションによるジョイン

	```ruby
	Post.joins(comments: :guest)
	```

.EN	#### Joining Nested Associations (Multiple Level)
.JA	#### 入れ子 (多段) になったアソシエーションによるジョイン

	```ruby
	Category.joins(posts: [{comments: :guest}, :tags])
	```

.EN	### Specifying Conditions on the Joined Tables
.JA	### ジョイン用テーブルを使った条件の指定

.EN	You can specify conditions on the joined tables using the regular "Array":#array-conditions and "String":#pure-string-conditions conditions. "Hash conditions":#hash-conditions provides a special syntax for specifying conditions for the joined tables:
.JA	通常の "配列による条件指定":#array-conditions または "文字列による条件指定":#pure-string-conditions を、ジョイン用テーブル (joined table) に対して指定できます。 "ハッシュによる条件指定":#hash-conditions は、ジョイン用テーブルに対して特別な文法を提供します:

	```ruby
	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
	Client.joins(:orders).where('orders.created_at' => time_range)
	```

.EN	An alternative and cleaner syntax to this is to nest the hash conditions:
.JA	より明確な別の方法として、ハッシュによる条件指定を入れ子にする方法があります:

	```ruby
	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
	Client.joins(:orders).where(orders: {created_at: time_range})
	```

.EN	This will find all clients who have orders that were created yesterday, again using a `BETWEEN` SQL expression.
.JA	この例では SQL の `BETWEEN` 式を使って、昨日に注文を作成した顧客をすべて検索します。

.EN	Eager Loading Associations
.EN	--------------------------
.JA	Eager ローディングアソシエーション
.EN	------------------------------------

.EN	Eager loading is the mechanism for loading the associated records of the objects returned by `Model.find` using as few queries as possible.
.JA	Eager ローディングは、 `Model.find` によって返されるオブジェクトに関連した (associated) レコードを、できるだけ少ないクエリを使って読み込むメカニズムです。

.EN	**N + 1 queries problem**
.JA	**N + 1 クエリ問題**

.EN	Consider the following code, which finds 10 clients and prints their postcodes:
.JA	次のようなコードを考えます。これは、顧客を 10 名検索してそれらの郵便番号を表示しています:

.EN	```ruby
.EN	clients = Client.all(limit: 10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	```

.EN	This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 ( to find 10 clients ) <plus> 10 ( one per each client to load the address ) = **11** queries in total.
.JA	このコードは、一見問題がなさそうに思えます。しかし実行されるクエリの総数が問題となります。上のコードでは、1 個 ( 顧客 10 名を検索するため ) <plus> 10 個 ( 顧客ごとに住所を読み込むため ) = **11 個**のクエリが実行されます。

.EN	**Solution to N + 1 queries problem**
.JA	**N + 1 クエリ問題を解決する方法**

.EN	Active Record lets you specify all the associations in advanced that are going to be loaded. This is possible by specifying the `includes` method of the `Model.find` call. With `includes`, Active Record ensures that all the specified associations are loaded using minimum possible number of queries.
.JA	Active Record では、読み込まれるであろうアソシエーションを事前にすべて指定できます。これは `Model.find` の呼び出しに `includes` メソッドを指定することで実現できます。Active Record では、すべての指定されたアソシエーションが、最小のクエリ数で読み込まれます。

.EN	Revisiting the above case, we could rewrite `Client.all` to use eager load addresses:
.JA	上で出た例を改訂して、eager ローディングを使って住所を読み込むよう `Client.all` を書き直してみましょう:

.EN	```ruby
.EN	clients = Client.includes(:address).limit(10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	```

.EN	The above code will execute just **2** queries, as opposed to **11** queries in the previous case:
.JA	前は **11 個**のクエリが実行されたのに対し、上のコードはちょうど **2 個**のクエリだけが実行されます。

	```sql
	SELECT * FROM clients LIMIT 10
	SELECT addresses.* FROM addresses
	  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
	```

.EN	### Eager Loading Multiple Associations
.JA	### 複数のアソシエーションに体する Eager ローディング

.EN	Active Record lets you eager load any possible number of associations with a single `Model.find` call by using an array, hash, or a nested hash of array/hash with the `includes` method.
.JA	Active Record では、配列やハッシュやそれらの入れ子を `includes` メソッドに指定することで、ひとつの `Model.find` 呼び出しに対して任意の数のアソシエーションを Eager ローディングで読み込めます。

.EN	#### Array of Multiple Associations
.JA	#### 複数のアソシエーションを含む配列

	```ruby
	Post.includes(:category, :comments)
	```

.EN	This loads all the posts and the associated category and comments for each post.
.JA	この例はすべての投稿 (post) と、各投稿に関連したカテゴリやコメントを読み込みます。
.JA	〔訳注: どこに配列が?〕

.EN	#### Nested Associations Hash
.JA	#### ネストしたアソシエーションのハッシュ

	```ruby
	Category.includes(posts: [{comments: :guest}, :tags]).find(1)
	```

.EN	The above code finds the category with id 1 and eager loads all the posts associated with the found category. Additionally, it will also eager load every posts' tags and comments. Every comment's guest association will get eager loaded as well.
.JA	上のコードは、id が 1 であるカテゴリを検索し、そのカテゴリに関連したすべての投稿 (post) を Eager ローディングを使って読み込みます。また読み込まれた投稿に関連するタグとコメントも Eager ローディングを使って読み込みます。同様にすべてのコメントにおいても、ゲストのアソシエーションが Eager ローディングで読み込まれます。

.EN	### Specifying Conditions on Eager Loaded Associations
.JA	### Eager ローディングで読み込まれたアソシエーションに対する条件指定

.EN	Even though Active Record lets you specify conditions on the eager loaded associations just like `joins`, the recommended way is to use "joins":#joining-tables instead. 
.JA	Active Record は Eager ローディングで読み込まれたアソシエーションに対しても、ちょうど `joins` のときのように条件指定を行うことができますが、素直に "joins":#joining-tables メソッドを使うほうをお勧めします。

.EN	Dynamic Finders
.EN	---------------
.JA	動的ファインダ
.JA	---------------

.EN	For every field (also known as an attribute) you define in your table, Active Record provides a finder method. If you have a field called `name` on your `Client` model for example, you get `find_by_name` and `find_all_by_name` for free from Active Record. If you have also have a `locked` field on the `Client` model, you also get `find_by_locked` and `find_all_by_locked`.
.JA	Active Record では、テーブルに定義したどのフィールド (属性ともいう) にも使えるようなファインダ (finder) メソッド〔訳注: 検索用メソッドのこと〕が用意されています。たとえば `Client` モデルに `name` というフィールドがあるとすると、Active Record では `find_by_name` と `find_all_by_name` というメソッドが自動的に利用可能になります。もし `locked` というフィールドが `Client` モデルにあれば、 `find_by_locked` と `find_all_by_locked` が利用可能です。〔訳注: これらは事前に定義されるものではなく、呼ばれたときに初めて定義される検索用メソッドであり、これらを動的ファインダ (dynamic finder) といいます。〕

.EN	You can do `find_last_by_*` methods too which will find the last record matching your argument.
.JA	また引数にマッチした中で最後のレコードを取ってくるための `find_last_by_*` メソッドも利用できます。

.EN	You can specify an exclamation point (`!`) on the end of the dynamic finders to get them to raise an `ActiveRecord::RecordNotFound` error if they do not return any records, like `Client.find_by_name!("Ryan")`
.JA	たとえば `Client.find_by_name!("Ryan")` のように、エクスクラメーションポイント (「`!`」のこと) を動的ファインダ名の最後につけると、該当するレコードが見つからなかった場合は `ActiveRecord::RecordNotFound` エラーが発生します。

.EN	If you want to find both by name and locked, you can chain these finders together by simply typing `and` between the fields for example `Client.find_by_name_and_locked("Ryan", true)`.
.JA	name と locked の両方のフィールドを使って検索したい場合は、たとえば `Client.find_by_name_and_locked("Ryan", true)` のように、単にそれらを `and` でつなげるだけでいいです。


.EN	There's another set of dynamic finders that let you find or create/initialize objects if they aren't found. These work in a similar fashion to the other finders and can be used like `find_or_create_by_name(params[:name])`. Using this will firstly perform a find and then create if the find returns `nil`. The SQL looks like this for `Client.find_or_create_by_name("Ryan")`:
.JA	動的ファインダの別の種類として、オブジェクトを検索し、見つからなければ新規作成/初期化を行うというものもあります。これらは、メソッド名が `find_or_create_by_name(params[:name])` のようになる以外は、他のファインダと同じように動作します。

	```sql
	SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
	BEGIN
    NSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
	COMMIT
	```

.EN	`find_or_create`'s sibling, `find_or_initialize`, will find an object and if it does not exist will act similar to calling `new` with the arguments you passed in. For example:
.JA	`find_or_create`'s の兄弟版として `find_or_initialize` があります。これは、まず検索を行い、見つからなかった場合は渡された引数を使って〔訳注: `create` ではなく〕 `new` を呼び出します。

	```ruby
	client = Client.find_or_initialize_by_name('Ryan')
	```

.EN	will either assign an existing client object with the name "Ryan" to the client local variable, or initialize a new object similar to calling `Client.new(name: 'Ryan')`. From here, you can modify other fields in client by calling the attribute setters on it: `client.locked = true` and when you want to write it to the database just call `save` on it.
.JA	上の場合だと、名前が "Ryan" である既存の顧客オブジェクトをローカル変数 client に代入するか、〔訳注: そのような顧客が見つからなければ〕 `Client.new(name: 'Ryan')` を呼び出して新しいオブジェクトを作成し初期化します。ここから、 `client.locked = true` のようにセッターメソッドを使って顧客の他のフィールドを変更できます。またそれをデータベースに保存したいときは `save` メソッドを呼び出します。

.EN	Finding by SQL
.EN	--------------
.JA	SQL による検索
.JA	--------------

.EN	If you'd like to use your own SQL to find records in a table you can use `find_by_sql`. The `find_by_sql` method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:
.JA	`find_by_sql` を使って、テーブル中のレコードを検索するための独自の SQL を指定できます。 `find_by_sql` メソッドは、たとえ 1 つのレコードしか返さないような SQL が指定されたとしても、オブジェクトの配列を返します。たとえば次のようなクエリが実行できます:

	```ruby
	Client.find_by_sql("SELECT * FROM clients
	  INNER JOIN orders ON clients.id = orders.client_id
	  ORDER clients.created_at desc")
	```

.EN	`find_by_sql` provides you with a simple way of making custom calls to the database and retrieving instantiated objects.
.JA	`find_by_sql` を使えば、データベースのカスタムコールを呼び出してインスタンス化されたオブジェクトを取り出すのが、簡潔に実行できます。

.EN	### `select_all`
.JA	### `select_all`

.EN	`find_by_sql` has a close relative called `connection#select_all`. `select_all` will retrieve objects from the database using custom SQL just like `find_by_sql` but will not instantiate them. Instead, you will get an array of hashes where each hash indicates a record.
.JA	`find_by_sql` とよく似たものに `connection#select_all` というのがあります。 `select_all` は `find_by_sql` と同様にカスタム SQL を使ってデータベースからオブジェクトを取り出しますが、インスタンス化を行いません。かわりに、レコードごとのハッシュを要素とする配列が返されます。

	```ruby
	Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")
	```

.EN	Existence of Objects
.EN	--------------------
.JA	オブジェクトの存在確認
.JA	-----------------------

.EN	If you simply want to check for the existence of the object there's a method called `exists?`. This method will query the database using the same query as `find`, but instead of returning an object or collection of objects it will return either `true` or `false`.
.JA	オブジェクトが存在するかどうかをチェックしたいだけなら、 `exists?` というメソッドが使えます。このメソッドは `find` と同じクエリを使ってデータベースを検索しますが、オブジェクトやそのコレクションを返すかわりに、 `true` または `false` を返します。

	```ruby
	Client.exists?(1)
	```

.EN	The `exists?` method also takes multiple ids, but the catch is that it will return true if any one of those records exists.
.JA	`exists?` メソッドは複数の id をとることができますが、そのうちのどれかひとつでも存在していれば true を返します。

	```ruby
	Client.exists?(1,2,3)
	# or
	Client.exists?([1,2,3])
	```

.EN	Further more, `exists` takes a `conditions` option much like find:
.JA	もっと言うと、 `exists` は find によく似た `conditions` オプションを取ることができます:

	```ruby
    Client.where(first_name: 'Ryan').exists?
	```

.EN	It's even possible to use `exists?` without any arguments:
.JA	引数なしで `exists?` を呼び出すことも可能です。

	```ruby
	Client.exists?
	```

.EN	The above returns `false` if the `clients` table is empty and `true` otherwise.
.JA	この場合、 `clients` テーブルが空なら `false` が返され、そうでなければ `true` が返されます。

.EN	Calculations
.EN	------------
.JA	計算
.EN	----

.EN	This section uses count as an example method in this preamble, but the options described apply to all sub-sections.
.JA	このセクションの前書きでは例として count メソッドを使用しますが、説明されたオプションはすべてのサブセクションで利用可能です。

.EN	`count` takes conditions much in the same way `exists?` does:
.JA	`count` では `exists?` と同じ方法で検索条件を指定できます:

	```ruby
	Client.count
	# SELECT count(*) AS count_all FROM clients
	```

.EN	Which will execute:
.JA	これは次のような SQL を実行します:

	```ruby
	Client.where(first_name: 'Ryan').count
	# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')
	```

.EN	You can also use the `includes` or `joins` methods for this to do something a little more complex:
.JA	より複雑なことをするのに `includes` メソッドや `joins` メソッドを使うことができます:

	```ruby
	Client.includes("orders").where(first_name: 'Ryan', orders: {status: 'received'}).count
	```

.EN	Which will execute:
.JA	これは次のような SQL を実行します:

	```sql
	SELECT count(DISTINCT clients.id) AS count_all FROM clients
	  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
	  (clients.first_name = 'Ryan' AND orders.status = 'received')
	```

.EN	This code specifies `clients.first_name` just in case one of the join tables has a field also called `first_name` and it uses `orders.status` because that's the name of our join table.
.JA	このコードでは、ジョイン用のテーブル〔訳注: である orders 〕も `first_name` というカラム名を持っている場合を考慮し、 `clients.first_name` を指定しています。またジョイン用のテーブルが `orders` なので、 `orders.status` を指定しています。〔訳注: 要レビュー〕

.EN	### Count
.JA	### カウント

.EN	If you want to see how many records are in your model's table you could call `Client.count` and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use `Client.count(:age)`.
.JA	モデルのテーブル中にどれだけのレコードがあるか調べたい場合、 `Client.count` を呼ぶとレコード数を返します。もっと詳しく調べたい、たとえばデータベース中のすべてのクライアントを現在の年齢とともに調べたい場合は、 `Client.count(:age)` のようにします。〔訳注: 要レビュー〕

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	オプションについては、前の "Calculations":#calculations セクションをご覧下さい。

.EN	### Average
.JA	### 平均値

.EN	If you want to see the average of a certain number in one of your tables you can call the `average` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のある数値の平均値を知りたい場合は、そのテーブルと対応するクラスの `average` メソッドを呼び出します。このメソッド呼び出しは次のような感じになるでしょう:

	```ruby
	Client.average("orders_count")
	```

.EN	This will return a number (possibly a floating point number such as 3.14159265) representing the average value in the field.
.JA	この例だと、フィールドの平均値を表す数 (典型的には 3.14159265 のような浮動小数点数) を返します。

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Minimum
.JA	### 最小値

.EN	If you want to find the minimum value of a field in your table you can call the `minimum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの最小値を調べたいなら、そのテーブルと対応するクラスの `minimum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.minimum("age")
	```

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Maximum
.JA	### 最大値

.EN	If you want to find the maximum value of a field in your table you can call the `maximum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの最大値を調べたいなら、そのテーブルと対応するクラスの `maximum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.maximum("age")
	```

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Sum
.JA	### 合計値

.EN	If you want to find the sum of a field for all records in your table you can call the `sum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの合計値を調べたいなら、そのテーブルと対応するクラスの `sum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.sum("orders_count")
	```

.EN	For options, please see the parent section,  "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	h3. Changelog
.JA	h3. 更新履歴

	"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/16

	* April 7, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
	* February 3, 2010: Update to Rails 3 by "James Miller":credits.html#bensie
	* February 7, 2009: Second version by "Pratik":credits.html#lifo
	* December 29 2008: Initial version by "Ryan Bigg":credits.html#radar
